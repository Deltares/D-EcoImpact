{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#vision","title":"Vision","text":"<p>D-Eco Impact is an open source spatial ecological impact postprocessing model. This model is focused on aquatic application, suitable for coastal, river, lake, rural and urban applications. The model applies criteria rules to environmental conditions to evaluate the ecological state. These environmental conditions can be of varying detail (e.g. expert knowledge, measurements, or model output). The criteria applied can be of varying complexity (e.g., hard boundaries, gradual boundaries, multi variant relationships and AI deduced models). D-Eco Impact makes sure that the technical burden of applying these criteria to these environmental conditions is reduced. By reducing this technical burden, the following benefits can be achieved:</p> <ul> <li>It will be easier to make use of differing environmental data sources and change them when new environmental model output or better describing data sources become available, without changing the ecological criteria.</li> <li>More time can be spent on exploring the ecological criteria used and improving on knowledge that supports them.</li> <li>The effect of changing the ecological criteria or underlying environmental data on the ecological result can be easier explored (e.g. spatial/ temporal resolution, accuracy of the environmental data used, missing pressures, knowledge rules used) while comparing the modelled result with the current situation in the field.</li> </ul> <p></p> <p>We distinguish between four types of users for D-Eco Impact:</p> <ul> <li>Users assessing the model results.</li> <li>Users working with the model using established functionality through the input file.</li> <li>Users expanding on the model by developing prototype functions on the existing framework.</li> <li>Developers or co-creators of the model adding accepted functionality that will be available to other users of the model.</li> </ul> <p></p> <p>To support D-Eco Impact in providing one environmental input dataset and the analyses of the results we make use of the HydroMT_habitat plugin. HydroMT_habitat combines and prepares environmental data from various sources (e.g., expert knowledge, measurements, or model output) to one coherent dataset of environmental conditions, ready to be analyzed by D-Eco Impact. This dataset is a NetCDF file following the UGRID data format. developed for storing 1D, 2D and 3D (unstructured) data. HydroMT_habitat is also meant as a post-processing module, translating the D-Eco Impact result to a user required data format (e.g., shapefile, geopackage, GeoTiff, CSV) and providing statistical summaries (e.g. area created, change with previous scenario, most limiting environmental variable, least limiting environmental variable). </p> <p></p>"},{"location":"development/","title":"Development D-Eco Impact","text":""},{"location":"development/#workflow","title":"Workflow","text":""},{"location":"development/#developer","title":"Developer:","text":"<ol> <li> <p>Move the jira issue you want to work on from \"todo\" into \"in progress\". (issue should be in the sprint, if not please discuss with product owner about changing the sprint scope).</p> </li> <li> <p>Create a development branch from the main branch with the name based on that of the issue  feat[issue id] {summary of the issue}. For example:      &gt; feat[DEI-123] Improve functionality A</p> <p>Then switch your local copy to the development branch.</p> </li> <li> <p>Commit the necessary changes with clear messages on what has been done.</p> </li> <li> <p>Verify if all checks have passed (a green checkmark is shown, not a red cross).</p> <p> Is one or more checks fail, they must be fixed before continuing.</p> </li> <li> <p>Once all checks pass, control if there are any changes in the main branch. If so, merge them to the development branch and fix all possible conflicts in the code, if any, and then go back to point 4 of this list.</p> </li> <li> <p>Move the issue from In progress to In review and create a pull-request with the name of the branch previously assigned:     &gt; feat[issue id]{summary of the issue}.</p> </li> </ol>"},{"location":"development/#reviewer","title":"Reviewer:","text":"<ol> <li>Change the status of the issue from In review to Being reviewed. This should make you automatically the assignee.</li> <li> <p>Look at the development details of the issue. </p> </li> <li> <p>Open the linked pull-request in GitHub.</p> </li> <li> <p>Change the reviewer to yourself if it didn't happen before, as indicated in point 1.</p> <p></p> </li> <li> <p>Go to the Files changed tab to see the modifications implemented for the issue.</p> <p></p> </li> <li> <p>Add your review comments (see comment on a PR documentation ).</p> <p>Some points to analyse during the review are: * does the code work, including corner cases? * is the code in the right place? * is it readable? * is the code documented (all public methods and classes should have doc strings)? * are nameing conventions used properly? * is there any duplication of the code? * Is the code maintainable? * is the code covered by tests? * are all tests and checks green? * are the commit messages clear enough and do the satisfy the conventions?</p> <p> 7. Set the status of the issue (comment, approve or request changes).  1. Change the status if the issue in Jira corrspondingly:</p> <ul> <li>Approved -&gt; In Test</li> <li>Request changes -&gt; To do</li> <li>Comment -&gt; In review (with the developer as assignee).</li> </ul> </li> </ol>"},{"location":"development/#tester","title":"Tester:","text":"<ol> <li> <p>Change issue status from \"in test\" to \"being tested\". This should make you the assignee.</p> </li> <li> <p>For a bug or improvement, check out the main branch and try to reproduce the issue or to get familiar with the previous functionality.</p> </li> <li> <p>Change your local check-out to the development branch (from which the pull-request was created).</p> </li> <li> <p>Test now the new functionality or bug fix by running the main script from python in a clean python environment.</p> </li> <li> <p>Try to think of situations or conditions that may have been forgotten to implement properly, and test these as well.</p> </li> <li> <p>Add comments in the issue with your findings (ok or not because ...). Describe enough in detail so that other people can easily reproduce any problems found. If needed, provide any required (additioonal) data.</p> </li> <li> <p>Move the issue in Jira to the new corresponding state:</p> <ul> <li>If the test is ok, to Merge.</li> <li>If the test is not ok, move to To do.</li> </ul> </li> </ol>"},{"location":"development/#if-test-is-succesful","title":"If test is succesful","text":"<ol> <li> <p>Go to pull request on GitHub.</p> </li> <li> <p>Check if there will be merge conflicts (shown by GitHub) and if the development branch is up to date with the main branch. </p> <ul> <li>If any merge conflicts are reported, then check with developer to resolve the merge issues.</li> <li>If the branch does not have any merge conflicts and is not up to date -&gt; press the update branch button.</li> </ul> </li> <li> <p>If the branch is up to date and does not have merge conflicts you can merge the pull request to the main branch.</p> </li> <li> <p>Change issue status in jira from \"merge\" to \"validate\".</p> </li> <li> <p>Change your local checkout to the main branch and do a few checks to see if the merge was correct.</p> </li> <li> <p>If the merge was successful, change issue status in jira from \"validate\" to \"done\".</p> </li> </ol>"},{"location":"development/#agreements","title":"Agreements","text":""},{"location":"development/#coding","title":"Coding:","text":"<ul> <li>We use the PEP8 style guide for python development.</li> <li>We use typing where possible.</li> <li>We avoid using global variables.</li> <li> <p>We use encapsulation by only making the necessary imports and variables public.</p> </li> <li> <p>For testing, we use the pytest module.</p> </li> <li>For checking the style guide, we use flake8 and pylint.</li> <li> <p>For managing external dependencies, we use poetry (.toml file).</p> </li> <li> <p>We prefer to use VS Code for development (sharing settings using vscode folder) with the following plugins:</p> <ul> <li>autoDocstring</li> <li>python</li> </ul> </li> </ul>"},{"location":"home/","title":"Introduction","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Proin magna est, consequat quis arcu pretium, venenatis eleifend mauris. Morbi varius, dolor nec tristique suscipit, libero nisi faucibus justo, a mattis erat massa volutpat arcu. Sed imperdiet semper sapien, at facilisis nulla lobortis sit amet. Morbi semper sem et diam iaculis, sit amet aliquam lacus lobortis. Duis scelerisque aliquam risus sit amet consectetur. Suspendisse molestie turpis sed dapibus viverra. Vestibulum ut rutrum ipsum. Quisque sollicitudin dictum semper.</p>"},{"location":"installation/","title":"Installation","text":"<p>D-Eco Impact is a command line operated model. To use D-Eco Impact (currently) an installation of Python and the used libraries is required. This is best achieved by installing D-Eco Impact in a virtual environment.</p>"},{"location":"installation/#conda-or-visual-studio-code","title":"Conda or Visual Studio Code","text":"<p>Conda is a package and environment manager that can be used to install the poetry package and other packages needed to run D-Eco Impact. </p> <ul> <li>Miniforge</li> <li>Miniconda</li> <li>Visual Studio code</li> </ul>"},{"location":"installation/#installation-of-d-eco-impact-with-conda-use-miniforge-or-miniconda","title":"Installation of D-Eco Impact with conda (use Miniforge or Miniconda)","text":"<p>Note: when using miniconda, make sure to update the defaults channel to conda-forge (instructions for changing the channel)!</p> <ol> <li> <p>Open a commandline tool (eg. cmd or powershell):   <code>sh   $ conda create -y -c pip --name &lt;env_name&gt; python=3.11</code></p> </li> <li> <p>Activate the newly created environment   <code>sh   $ conda activate &lt;env_name&gt;</code></p> </li> <li> <p>Move to the folder where you have placed the D-Eco Impact source code You can use cd ../ and cd  to move to the location or use windows explorer and type \u201ccmd\u201d + enter in the path bar. <li> <p>To install the required libraries Poetry is used.  Use poetry 1.3 or higher: (installation instructions) If you prefer to install poetry with conda then we recommed to install poetry only to the base environment.</p> </li> <p>Activate base environment:</p> <pre><code>$ conda activate base\n</code></pre> <p>Install poetry using pip:</p> <pre><code>$ pip install poetry\n</code></pre> <p>Activate your created environment:</p> <pre><code>$ conda activate &lt;env_name&gt;\n</code></pre> <ol> <li> <p>Poetry makes use of the poetry.lock and pyproject.toml (present in the D-Eco Impact folder) to find these required libraries. Execute the following command:   <code>poetry install</code> NB. If errors occur while installing the libraries, this might have to do with your administrative rights. Either start the cmd prompt \u201cAs administrator\u201d or discuss this with your IT support.</p> </li> <li> <p>Now D-Eco Impact is ready to use. You can test this by executing one of the input yaml files. To execute use the following in the command prompt while your environment is active:   <code>python main.py &lt;your_input_file&gt;.yaml</code></p> </li> </ol>"},{"location":"installation/#installation-d-eco-impact-with-visual-studio-code-and-venv","title":"Installation D-Eco impact with Visual Studio Code and venv","text":"<ol> <li>Install [Python version 3.11.2] (https://www.python.org/downloads/)</li> <li>Open Visual Studio Code.</li> <li>Press CRTL + Shift + P and type \u201cPython: Create Environment\u201d followed by enter, select \u201cVenv\u201d.</li> <li>Place the environment in the D-Eco Impact folder.</li> <li>Press CTRL + Shift + P and type \u201cPython: Select interpreter\u201d and select the newly created environment.</li> <li>In the terminal in Visual Studio Code execute the following command:   <code>pip install poetry</code></li> <li>In the terminal in Visual Studio Code execute the following command: poetry install</li> <li>Now D-Eco Impact is setup for use. You can test this by executing one of the input yaml files. To execute use the following in the command prompt while your environment is active:   <code>python main.py &lt;your_input_file&gt;.yaml</code></li> </ol>"},{"location":"installation/#how-to-cite","title":"How to Cite","text":"<p>If you found D-Eco Impact useful for your study, please cite it as:</p> <p>Weeber, M., Elzinga, H., Schoonveld, W., Van de Vries, C., Klapwijk, M., Mischa, I., Rodriguez Aguilera, D., Farrag, M., Ye, Q., Markus, A., Van Oorschot, M., Saager, P., &amp; Icke, J. (2024). D-Eco Impact (v0.3.0). Zenodo. https://doi.org/10.5281/zenodo.10941913</p>"},{"location":"manual/","title":"User manual","text":""},{"location":"manual/#introduction-to-user-manual","title":"Introduction to user manual","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Proin magna est, consequat quis arcu pretium, venenatis eleifend mauris. Morbi varius, dolor nec tristique suscipit, libero nisi faucibus justo, a mattis erat massa volutpat arcu. Sed imperdiet semper sapien, at facilisis nulla lobortis sit amet. Morbi semper sem et diam iaculis, sit amet aliquam lacus lobortis. Duis scelerisque aliquam risus sit amet consectetur. Suspendisse molestie turpis sed dapibus viverra. Vestibulum ut rutrum ipsum. Quisque sollicitudin dictum semper.</p>"},{"location":"api/business/application/","title":"Application","text":"<p>Module for Application class</p> <p>!!! classes     Application</p>"},{"location":"api/business/application/#decoimpact.business.application.Application","title":"<code> Application        </code>","text":"<p>Application for running command-line</p> Source code in <code>business/application.py</code> <pre><code>class Application:\n    \"\"\"Application for running command-line\"\"\"\n\n    # get version\n    APPLICATION_VERSION = read_version_number()\n    APPLICATION_NAME = \"D-EcoImpact\"\n    # separate version into major, minor and patch:\n    APPLICATION_VERSION_PARTS = list(map(int, APPLICATION_VERSION.split(\".\", 2)))\n\n    def __init__(\n        self,\n        logger: ILogger,\n        da_layer: IDataAccessLayer,\n        model_builder: IModelBuilder,\n    ):\n        \"\"\"Creates an application based on provided logger, data-access layer\n        and model builder\n\n        Args:\n            logger (ILogger): Logger that takes care of logging\n            da_layer (IDataAccessLayer): data-access layer for reading/writing\n            model_builder (IModelBuilder): builder for creating a model based on\n            IModelData\n        \"\"\"\n        self._logger = logger\n        self._da_layer = da_layer\n        self._model_builder = model_builder\n\n    def run(self, input_path: Path):\n        \"\"\"Runs application\n\n        Args:\n            input_path (Path): path to input file\n        \"\"\"\n\n        try:\n            # show application version\n            self._logger.log_info(f\"Application version: {self.APPLICATION_VERSION}\")\n\n            # read input file\n            model_data: IModelData = self._da_layer.read_input_file(input_path)\n            str_input_version = \"\".join([str(x) + \".\" for x in model_data.version])[:-1]\n            self._logger.log_info(f\"Input file version: {str_input_version}\")\n\n            # check version:\n            message = (\n                f\"Application version {self.APPLICATION_VERSION} is older\"\n                \" than version from input file {str_input_version}\"\n            )\n            # major version (app) should be equal or larger then input version --&gt; error\n            if self.APPLICATION_VERSION_PARTS[0] &lt; model_data.version[0]:\n                self._logger.log_error(message)\n            # minor version (app) should be equal or larger then input version --&gt; warn\n            elif self.APPLICATION_VERSION_PARTS[1] &lt; model_data.version[1]:\n                self._logger.log_warning(message)\n\n            # build model\n            for dataset in model_data.datasets:\n                input_files = self._da_layer.retrieve_file_names(dataset.path)\n                output_path_base = Path(model_data.output_path)\n                for key, file_name in input_files.items():\n                    dataset.path = file_name\n                    output_path = self._generate_output_path(output_path_base, key)\n\n                    model_data.partition = key\n                    model = self._model_builder.build_model(model_data)\n\n                    # run model\n                    _ModelRunner.run_model(model, self._logger)\n\n                    # write output file\n                    if model.status == _ModelStatus.FINALIZED:\n                        settings = OutputFileSettings(\n                            self.APPLICATION_NAME, self.APPLICATION_VERSION\n                        )\n                        settings.variables_to_save = model_data.output_variables\n\n                        self._da_layer.write_output_file(\n                            model.output_dataset, output_path, settings\n                        )\n\n        except Exception as exc:  # pylint: disable=broad-except\n            self._logger.log_error(f\"Exiting application after error: {exc}\")\n\n    def _generate_output_path(self, output_path_base, key):\n        if \"*\" in output_path_base.stem:\n            output_path = Path(str(output_path_base).replace(\"*\", key))\n        else:\n            partition_part = \"\"\n            if key:\n                partition_part = f\"_{key}\"\n            output_path = Path.joinpath(\n                output_path_base.parent,\n                f\"{output_path_base.stem}{partition_part}{output_path_base.suffix}\",\n            )\n        return output_path\n</code></pre>"},{"location":"api/business/application/#decoimpact.business.application.Application.__init__","title":"<code>__init__(self, logger: ILogger, da_layer: IDataAccessLayer, model_builder: IModelBuilder)</code>  <code>special</code>","text":"<p>Creates an application based on provided logger, data-access layer and model builder</p> <p>Parameters:</p> Name Type Description Default <code>logger</code> <code>ILogger</code> <p>Logger that takes care of logging</p> required <code>da_layer</code> <code>IDataAccessLayer</code> <p>data-access layer for reading/writing</p> required <code>model_builder</code> <code>IModelBuilder</code> <p>builder for creating a model based on</p> required Source code in <code>business/application.py</code> <pre><code>def __init__(\n    self,\n    logger: ILogger,\n    da_layer: IDataAccessLayer,\n    model_builder: IModelBuilder,\n):\n    \"\"\"Creates an application based on provided logger, data-access layer\n    and model builder\n\n    Args:\n        logger (ILogger): Logger that takes care of logging\n        da_layer (IDataAccessLayer): data-access layer for reading/writing\n        model_builder (IModelBuilder): builder for creating a model based on\n        IModelData\n    \"\"\"\n    self._logger = logger\n    self._da_layer = da_layer\n    self._model_builder = model_builder\n</code></pre>"},{"location":"api/business/application/#decoimpact.business.application.Application.run","title":"<code>run(self, input_path: Path)</code>","text":"<p>Runs application</p> <p>Parameters:</p> Name Type Description Default <code>input_path</code> <code>Path</code> <p>path to input file</p> required Source code in <code>business/application.py</code> <pre><code>def run(self, input_path: Path):\n    \"\"\"Runs application\n\n    Args:\n        input_path (Path): path to input file\n    \"\"\"\n\n    try:\n        # show application version\n        self._logger.log_info(f\"Application version: {self.APPLICATION_VERSION}\")\n\n        # read input file\n        model_data: IModelData = self._da_layer.read_input_file(input_path)\n        str_input_version = \"\".join([str(x) + \".\" for x in model_data.version])[:-1]\n        self._logger.log_info(f\"Input file version: {str_input_version}\")\n\n        # check version:\n        message = (\n            f\"Application version {self.APPLICATION_VERSION} is older\"\n            \" than version from input file {str_input_version}\"\n        )\n        # major version (app) should be equal or larger then input version --&gt; error\n        if self.APPLICATION_VERSION_PARTS[0] &lt; model_data.version[0]:\n            self._logger.log_error(message)\n        # minor version (app) should be equal or larger then input version --&gt; warn\n        elif self.APPLICATION_VERSION_PARTS[1] &lt; model_data.version[1]:\n            self._logger.log_warning(message)\n\n        # build model\n        for dataset in model_data.datasets:\n            input_files = self._da_layer.retrieve_file_names(dataset.path)\n            output_path_base = Path(model_data.output_path)\n            for key, file_name in input_files.items():\n                dataset.path = file_name\n                output_path = self._generate_output_path(output_path_base, key)\n\n                model_data.partition = key\n                model = self._model_builder.build_model(model_data)\n\n                # run model\n                _ModelRunner.run_model(model, self._logger)\n\n                # write output file\n                if model.status == _ModelStatus.FINALIZED:\n                    settings = OutputFileSettings(\n                        self.APPLICATION_NAME, self.APPLICATION_VERSION\n                    )\n                    settings.variables_to_save = model_data.output_variables\n\n                    self._da_layer.write_output_file(\n                        model.output_dataset, output_path, settings\n                    )\n\n    except Exception as exc:  # pylint: disable=broad-except\n        self._logger.log_error(f\"Exiting application after error: {exc}\")\n</code></pre>"},{"location":"examples/maas/","title":"Meuse (2D) case on Potamogeton spp. habitat suitability","text":"<p>Based on the knowledgerules available through the KRW-Verkenner Rijkswateren the aquatic plant species Long-leaf pond weed (Potamogeton nodosus) and Sago pondweed (Potamogeton spectinatus) the criteria for flow velocity and water depth were applied to a predictive hydrodynamic scenario of the Meuse river. Based on these knowledge rules the habitat suitability for both species was assessed. The results of P. nodosus has been shown below.</p> WetenschappelijkeNaam Compartiment VariabeleNaam Eenheid Ondergrens Bovengrens Potamogeton nodosus Omgeving GemDiepte m 0,05 2 Potamogeton nodosus Water Stroomsnelheid m/s 0 2 Potamogeton nodosus Water Droogval Categorie 1 2 Potamogeton pectinatus Omgeving GemDiepte m 0,05 10 Potamogeton pectinatus Water Stroomsnelheid m/s 0 2,5 Potamogeton pectinatus Water Droogval Categorie 1 2 <p>Habitat suitability criteria for flow velocity, water depth and desiccation for Potamogeton nodosus and Potamogeton pectinatus.</p> <p></p>"},{"location":"examples/volkerak/","title":"VKZM (3D) case on water level and chloride policy","text":"<p>Based on the criteria set in the \u201cWaterakkoord\u201d by RWS the water level in Lake Volkerak is not allowed to exceed under normal conditions 0.15 m NAP or go lower than -0.10 m NAP. In addition to this threshold the chloride level should not exceed 450 mg/l (between mid-March and mid-September, as measured at \u201cBathse burg\u201d).  This case was simplified by testing that the chloride level does not exceed 450 mg/l at any moment in the year in the top layer of the model. The dry embankment area and islands included in the model were not excluded from assessment (hence is indicated as where water level is too high in the result).</p> <p></p>"},{"location":"manual/input/","title":"Structure of the model input file and functionality","text":"<p>D-Eco Impact is steered through a YAML input file. This input file informs the model which data to use, what ecological knowledge rules to apply and where to write the output data.  The easiest way to edit these YAML files is by using Notepad++. When starting with your first application with D-Eco Impact, make use of earlier models to setup your YAML input file and edit from there. When running the YAML file with D-Eco Impact, the model will inform you if there are inconsistencies in the file provided. </p>"},{"location":"manual/input/#importing-and-exporting-data","title":"Importing and exporting data","text":"<p>Importing and exporting data is always arranged in the input-data and output-data header in the YAML file.  </p> <pre><code>version: \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.\n\ninput-data:\n    \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.\nrules:\n    \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.\noutput-data:\n    \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.\n</code></pre> <p>The variables present in the input data, provided through \u201cfilename\u201d, are selected for use. The filename is able to accept a pattern including a * in the name. Instead of using one single input file, all files matching the pattern within the folder are being processed by the same input_file.yaml. So, for example, if in a folder there are two files test_1.nc and test_2.nc, the user can set the filename to \"test_*.nc\" and both files will be processed. It is possible to filter the input data by providing a start date or end date (format: \"dd-mm-yyyy\"); this is optional. The variables that are used can be selected under \u201cvariable_mapping\u201d. Here, you are also able to rename variables as the name used for storage is often cryptic. </p> <p>At output data the location where the output file needs to be written can be provided through \u201cfilename\u201d. In this output file only variables that have been used from the input data and variables that have been created in the model are stored. If the user gives a pattern (filename with asterisk for partitions) in the input-data filename, the output-data filename needs to match the corresponding amount of files that are being processed. Again in the example of two files (test_1.nc and test_2.nc) and an input-data filename of \"test_*.nc\", the user can either give an output-data filename with or without an asterisk. Without an asterisk (eg \"output.nc\"), the partitioned part of the input filename is used and extended to the output-data filename (\"output_1.nc\" and \"output_2.nc\"). With an asterisk (eg \"*_output.nc\") the * will provide the place where the partitioned part of the input file will be placed (\"1_output.nc\" and \"2_output.nc\"). It is possible to reduce the file size with the optional parameter \"save_only_variables\", which can take the name of one or several variables. The model needs at least one rule under \u201crules\u201d to execute.</p> <pre><code>#FORMAT\nversion: &lt;D-Eco_Impact_version_nr&gt;\n\ninput-data:\n  - dataset:\n      filename: &lt;path_to_file_including_file_name_and_type&gt;\n      start_date: \"&lt;start_date&gt;\"\n      end_date: \"&lt;end_date&gt;\"\n      variable_mapping:\n        &lt;variable1_input_file&gt;: \"&lt;variable1_name_in_model&gt;\"\n        &lt;variable2_input_file&gt;: \"&lt;variable2_name_in_model&gt;\"\n        \u2026\u2026\u2026\nrules:\n        \u2026\u2026\u2026\noutput-data:\n  filename: &lt;path_to_file_including_file_name_and_type&gt;\n  save_only_variables: &lt;variable, or list_of_variables&gt;\n</code></pre> <pre><code>#EXAMPLE  : Reading and writing an example model of the Volkerak-Zoommeer\nversion: 0.1.5\n\n# Mapping: mesh2d_sa1              : Salinity (PSU)\n#          mesh2d_s1                : Water level (m NAP)\n#          mesh2d_waterdepth : Water depth (m NAP)\ninput-data:\n  - dataset:\n      filename: examples/data/FM-VZM_0000_map.nc\n      start_date: \"01-01-2011\"\n      end_date: \"31-12-2015\"\n      variable_mapping:\n        mesh2d_sa1: \"salinity\"\n        mesh2d_s1: \"water_level\"\n        mesh2d_waterdepth: \"water_depth\"\n\nrules:\n  - multiply_rule:\n      name: make variable test\n      description: Make a variable called test for testing purposes\n      multipliers: [1.0]\n      input_variable: water_depth\n      output_variable: test\n\noutput-data:\n  filename: examples/data_out/results_test8c.nc\n  save_only_variables: test\n</code></pre>"},{"location":"manual/input/#functionality","title":"Functionality","text":"<p>The functionality is always arranged in the form of rules under the rules header in the yaml file.</p> <pre><code>version: \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.\n\ninput-data:\n    \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.\nrules:\n    \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.\noutput-data:\n    \u2026\u2026\u2026\u2026\u2026\u2026\u2026\u2026.\n\n</code></pre> <p>The output of the following functionalities has been shown for a section of the Lake Volkerak 3D hydrodynamic model in the Netherlands. This hydrodynamic model output contains 6 years of data (2011 \u2013 2016), with a timestep of 10 days. The 3D hydrodynamic model has been setup with 22 vertical layers and 3290 horizontal flexible mesh grid cells.</p> <p></p>"},{"location":"manual/input/#rules","title":"Rules","text":""},{"location":"manual/input/#multiply-rule","title":"Multiply rule","text":"<pre><code>- multiply_rule:\n      name: &lt;name_of_rule_in_text&gt;\n      description: &lt;description_of_rule_in_text&gt;\n      multipliers: [&lt;value_to_multiply_with&gt;]\n      input_variable: &lt;one_input_variable_name&gt;\n      output_variable: &lt;one_output_variable_name&gt;\n\n- multiply_rule:\n      name: &lt;name_of_rule_in_text&gt;\n      description: &lt;description_of_rule_in_text&gt;\n      multipliers_table:\n            - [\"start_date\", \"end_date\", \"multipliers\"]\n            - [&lt;DD-MM&gt;, &lt;DD-MM&gt;, [&lt;value_to_multiply_with&gt;]]\n            - [&lt;DD-MM&gt;, &lt;DD-MM&gt;, [&lt;value_to_multiply_with&gt;]]\n      input_variable: &lt;one_input_variable_name&gt;\n      output_variable: &lt;one_output_variable_name&gt;\n</code></pre> <p>The multiply rule allows for multiplication of variables. This could be used for unit transformation (e.g., salinity to chloride) or scenario creation (e.g., water level 80% of existing value). The rule operates on all cells both 3D (in horizontal as vertical) as in the time axes. The same dimensions are returned at the output variable. The rule needs to be applied to an existing variable. A new variable is created when the rule is executed.</p> <p>When using the multiply rule with a start and end date (or multiple start and end dates) all periods that are not covered will be set to NaN. In this way the multiply rule can also be used as a filter in time. NaNs are ignored by any further calculations (for example the time_aggregation_rule).</p> <pre><code>#EXAMPLE: Salinity (psu) to chloride (mg/l) in a freshwater environment.\n- multiply_rule:\n      name: Salinity to chloride\n      description: Converts salinity (psu) to chloride (CL- mg/l) for fresh water environments\n      multipliers: [0.0018066, 1e5]\n      input_variable: salinity\n      output_variable: chloride\n\n- multiply_rule:\n      name: Select only the summer half year for chloride\n      description: Select only the summer half year for chloride as this is important for plant growth\n      multipliers_table:\n            - [\"start_date\", \"end_date\", \"multipliers\"]\n            - [\"15-04\"     , \"15-09\"   ,         [1.0]]\n      input_variable:  chloride\n      output_variable: chloride_grow_period\n\n</code></pre> <p></p>"},{"location":"manual/input/#layer-filter-rule","title":"Layer filter rule","text":"<pre><code>FORMAT\n- layer_filter_rule:\n      name: &lt;name_of_rule_in_text&gt;\n      description: &lt;description_of_rule_in_text&gt;\n      layer_number: &lt;integer_nr_of_layer&gt;\n      input_variable: &lt;one_3D_input_variable_name&gt;\n      output_variable: &lt;one_output_variable_name&gt;\n\n</code></pre> <p>The layer filter rule allows for the extraction of a layer from 3D variables. This could be used for extracting the top layer or bottom layer (e.g., from a multi layered model result). The rule operates on all layers in a 3D variable (in the vertical) as in the time axes and returns a 2D result with the time axes intact. The rule needs to be applied to an existing 3D variable. A new 2D variable is created when the rule is executed.</p> <pre><code>#EXAMPLE  : Extracts the chloride concentration at surface.\n  - layer_filter_rule:\n      name: Extract chloride at surface\n      description: Extracts the chloride concentration at surface\n      layer_number: 22\n      input_variable: chloride\n      output_variable: chloride_top_layer\n\n</code></pre> <p></p>"},{"location":"manual/input/#time-aggregation-rule","title":"Time aggregation rule","text":"<pre><code>FORMAT\n- time_aggregation_rule:\n      name: &lt;name_of_rule_in_text&gt;\n      description: &lt;description_of_rule_in_text&gt;\n      operation: &lt;statistic_opperation_applied&gt;\n      time_scale : &lt;time_aggregation_applied&gt;\n      input_variable: &lt;one_input_variable_name&gt;\n      output_variable: &lt;one_output_variable_name&gt;\n</code></pre> <p>The time aggregation rule allows for calculating a statistical summary over the time axes of 3D and 2D variables. This could be used for calculating the maximum value over a year (e.g., for water level) or the minimum value over a month (e.g., oxygen concentration). The rule operates both on 3D variables and 2D variables as long as they have a time axis and returns a 3D or 2D result depending on input with the statistic calculated for a new time axis (e.g., year or month). Operations available: Add, Average, Median, Min, Max, period statistics, Stdev and Percentile(n). When using percentile, add a number for the nth percentile with brackets like this: percentile(10). Stdev calculates the standard- deviation over the time period. Under period statistics are explained further in the text.</p> <p>Time aggregation available: Year, Month</p> <p>The rule needs to be applied to an existing 2D/3D variable with time axis. A new 2D/3D variable with new time axis is created when the rule is executed. With a year timestep the result is written to the last day of the year, with a month timestep the result is written to the last day of the month per year.</p> <pre><code>#EXAMPLE  : Calculate the maximum water level in a year.\n  - time_aggregation_rule:\n      name: Maximum water level year\n      description: Get maximum water level in a year\n      operation: MAX\n      time_scale: year\n      input_variable: water_level\n      output_variable: MAX_water_level_year\n</code></pre> <p></p> <p>Period statistics: Time aggregation rule with COUNT_PERIODS, AVG_DURATION_PERIODS, MIN_DURATION_PERIODS and MAX_DURATION_PERIODS</p> <p>When the operation type period statistics is used, the user needs to make sure that the input data is always consisting of only 1 and 0. If there is no such layer, the user can make a combination of for example the classification rule together with the time aggregation rule. For example, water depth can be used to check whether the cells are dry or not (this can be done with a classification rule) and with the COUNT_PERIODS operation type in the time aggregation rule the number of consecutive periods within a year or month can be calculated (nr). AVG_DURATION_PERIODS, MIN_DURATION_PERIODS and MAX_DURATION_PERIODS take the respective statistic of the duration for those consecutive periods (duration).</p> <pre><code>#EXAMPLE:\n\nCalculate the number of consecutive periods of dry time monthly\n    - classification_rule:\n        name: Classify dry time\n        description: Classify to 0 and 1 the dry time\n        criteria_table:\n            - [\"output\", \"water_depth\"]\n            - [0, \"&gt;0.10\"]\n            - [1, \"&lt;0.10\"]\n        input_variables: [\"water_depth\"]\n        output_variable: dry_time_classified\n\n    - time_aggregation_rule:\n        name: Count periods\n        description: Count periods\n        operation: COUNT_PERIODS\n        time_scale: month\n        input_variable: dry_time_classified\n        output_variable: COUNT_PERIODS_water_level_month\n</code></pre>"},{"location":"manual/input/#step-function-rule","title":"Step function rule","text":"<pre><code>FORMAT\n- step_function_rule::\n      name: &lt;name_of_rule_in_text&gt;\n      description: &lt;description_of_rule_in_text&gt;\n      limit_response_table:\n            - [ \"limit\", \"response\"]\n            - [&lt;limit_value&gt;, &lt;response_value&gt;]\n            - [&lt;limit_value&gt;, &lt;response_value&gt;]\n      input_variable: &lt;one_input_variable_name&gt;\n      output_variable: &lt;one_output_variable_name&gt;\n</code></pre> <p>The step function rule performs stepwise classification on the provided values of 3D and 2D variables time dependent arrays. This could be used for translating variables into classes (e.g., salinity classes based on salinity) or indicate suitable/unsuitable ranges (e.g., checking whether the water level falls between the maximum and minimum water level policy criteria). The rule operates both on 3D variables and 2D variables, independent of the time axes, and returns a binominal or classes in a 3D or 2D result, either with time axis, depending on input. </p> <p>The rule needs to be applied to an existing 2D/3D variable with or without time axis. A new 2D/3D variable with or without time axis is created when the rule is executed.</p> <pre><code>#EXAMPLE  : Salinity classes.\n    - step_function_rule:\n      name: Classify salinity\n      description: Make distinction between 0.0 \u2013 0.5 , 0.5 \u2013 1.2, 1.2 \u2013 1.3 and &gt;1.3 psu\n      limit_response_table:\n            - [ limit, response]\n            - [-999.0 , 0.0 ]\n            - [   0.0 , 1.0 ]\n            - [   0.5 , 2.0 ]\n            - [   1.2 , 3.0 ]\n            - [   1.3 , 4.0 ]\n            - [ 999.0 , 4.0 ]\n      input_variable: salinity\n      output_variable: salinity_class\n\n</code></pre> <p></p> <p></p> <pre><code>#EXAMPLE  : Check if the water level falls within the range of -0.10 and +0.15 m NAP.\n  - step_function_rule:\n      name: Check water level policy\n      description: Check if water level is within -0.10 (minimum) and +0.15 (maximum) m NAP\n      limit_response_table:\n            - [ limit, response]\n            - [-999.0  , 0.0 ]\n            - [  -0.10 , 1.0 ]\n            - [   0.15 , 0.0 ]\n            - [ 999.0  , 0.0 ]\n      input_variable: water_level\n      output_variable : water_level_policy\n</code></pre> <p></p> <p></p>"},{"location":"manual/input/#response-curve-rule","title":"Response curve rule","text":"<pre><code>FORMAT\n- response_curve_rule:\n      name: &lt;name_of_rule_in_text&gt;\n      description: &lt;description_of_rule_in_text&gt;\n      response_table:\n            - [ \"input\", \"output\"]\n            - [&lt;limit_value&gt;, &lt;response_value&gt;]\n            - [&lt;limit_value&gt;, &lt;response_value&gt;]\n      input_variable: &lt;one_input_variable_name&gt;\n      output_variable: &lt;one_output_variable_name&gt;\n</code></pre> <p>The response curve rule performs a linear interpolation over the provided values of the variables of 3D and 2D variables time dependent arrays. This could be used for a fuzzy logic translation of variables into ecological responses to these variables (e.g., suitability for aquatic plants based on light availability). The rule operates both on 3D variables and 2D variables, independent of the time axes, and returns decimal or fractional values in a 3D or 2D result, either with time axis, depending on input.</p> <p>The rule needs to be applied to an existing 2D/3D variable with or without time axis. A new 2D/3D variable with or without time axis is created when the rule is executed.</p> <pre><code>#EXAMPLE  : Response of the habitat suitability of Long-leaf pond weed\n# (Potamogeton nodosus)  to water depth.\n# Suitable between 0.0 \u2013 2.0 m and highly suitable between 0.5 \u2013 1.0 m\n- response_curve_rule:\n      name: HSI Pond weed water depth\n      description: Reponse of Pond weed (Potamogeton nodosus) to water depth\n      response_table:\n           - [\"input\",   \"output\"]\n           - [-999.0 ,   0.0 ]\n           - [   0.0 ,   0.0 ]\n           - [   0.5 ,   1.0 ]\n           - [   1.0 ,   1.0 ]\n           - [   2.0 ,   0.0 ]\n           - [ 999.0 ,   0.0 ]\n      input_variable: water_depth\n      output_variable: HSI_Pnodosus_water_depth\n\n</code></pre> <p></p> <p></p>"},{"location":"manual/input/#combine-results-rule","title":"Combine results rule","text":"<pre><code>FORMAT\n- combine_results_rule:\n      name: &lt;name_of_rule_in_text&gt;\n      description: &lt;description_of_rule_in_text&gt;\n      operation: &lt;statistic_opperation_applied&gt;\n      input_variables: [&lt;list with_input_variable_names&gt;]\n      output_variable: &lt;one_output_variable_name&gt;\n</code></pre> <p>The combine results rule combines the output of two or more variables to one output variable. The way this data is combined depends on the operation chosen. This could be used for adding mutual exclusive results (e.g., habitat suitability based on flow velocity and water depth) or asses difference between results (e.g., waterlevel and bathymetry to get the water depth).The rule operates one or multiple  3D variables or 2D variables, independent of the time axes, as long as these all have the same dimensions and returns a single 3D or 2D result, either with time axis, depending on input.</p> <p>Operations available: Add, Subtract, Multiply, Average, Median, Min and Max</p> <p>The rule needs to be applied to an existing 2D/3D variables with or without time axis. A new 2D/3D variable with or without time axis is created when the rule is executed.</p> <pre><code>#EXAMPLE  : Calculate bathymetry over time\n# This is just an example, there is a variable bed level without time (mesh2d_flowelem_bl)\n\n- combine_results_rule:\n      name: Calculate bathymetry\n      description: Calculate bathymetry over time by adding water level and water depth\n      operation: subtract\n      input_variables: [\"water_level\",\"water_depth\"]\n      output_variable: bathymetry_time\n\n</code></pre> <p></p> <p></p>"},{"location":"manual/input/#formula-rule","title":"Formula rule","text":"<pre><code>FORMAT\n- formula_rule:\n      name: &lt;name_of_rule_in_text&gt;\n      description: &lt;description_of_rule_in_text&gt;\n      formula: &lt;statistic_opperation_applied&gt;\n      input_variables: [&lt;list with_input_variable_names&gt;]\n      output_variable: &lt;one_output_variable_name&gt;\n</code></pre> <p>With the formula based rule multiple variables can be combined in a flexible way. Operations that are supported are the standard operators.</p> <p>The rule needs to be applied to an existing 2D/3D variables with or without time axis. A new 2D/3D variable with or without time axis is created when the rule is executed.</p> <pre><code>#EXAMPLE  : Calculate bathymetry over time\n# This is just an example, there is a variable bedlevel without time (mesh2d_flowelem_bl)\n\n- formula_rule:\n      name: Calculate bathymetry\n      description: Calculate bathymetry over time by adding water level and water depth\n      formula: water_level + water_depth\n      input_variables: [\"water_level\",\"water_depth\"]\n      output_variable: bathymetry_time\n</code></pre> <p>A lot of operators are supported with the formula based rule. Given two variables \"x\" and \"y\", formulas can be implemented for the following operators:</p> Operator Name Example + Addition x + y - Subtraction x - y * Multiplication x * y / Division x / y % Modulus x % y ** Exponentiation x ** y // Floor division x // y <p>When a formula results in a boolean, it will be converted to a float result. Meaning that True = 1 and False = 0. Comparison, logical, identity, identity and bitwise operators are supported:</p> Operator Name Example == Equal x == y != Not equal x != y &gt; Greater than x &gt; y &lt; Less than x &lt; y &gt;= Greater than or equal to x &gt;= y &lt;= Less than or equal to x &lt;= y // Floor division x // y and Returns True if both statements are true x &lt; 5 and  x &lt; 10 or Returns True if one of the statements is true x &lt; 5 or x &lt; 4 not Reverse the result, returns False if the result is true not(x &lt; 5 a is Returns True if both variables are the same object x is y is not Returns True if both variables are not the same object x is not y in Returns True if a sequence with the specified value is present in the object x in y not in Returns True if a sequence with the specified value is not present in the object x not in Operator Name Description Example &amp; AND Sets each bit to 1 if both bits are 1 x &amp; y | OR Sets each bit to 1 if one of two bits is 1 x | y ^ XOR Sets each bit to 1 if only one of two bits is 1 x ^ y ~ NOT Inverts all the bits ~x &lt;&lt; Zero fill left shift Shift left by pushing zeros in from the right and let the leftmost bits fall off x &lt;&lt; 2 &gt;&gt; Signed right shift Shift right by pushing copies of the leftmost bit in from the left, and let the rightmost bits fall off x &gt;&gt; 2 <p>For more information on these operators click here.</p>"},{"location":"manual/input/#multiple-classification-rule","title":"(Multiple) Classification rule","text":"<pre><code>FORMAT\n- classification_rule:\n      name: &lt;name_of_rule_in_text&gt;\n      description: &lt;description_of_rule_in_text&gt;\n      criteria_table:\n            - [ \"output\"       , &lt;input_variable_name1&gt;, &lt;input_variable_name2&gt;]\n            - [&lt;response_value&gt;,       &lt;criteria_range&gt;,       &lt;criteria_range&gt;]\n            - [&lt;response_value&gt;,       &lt;criteria_range&gt;,       &lt;criteria_range&gt;]\n      input_variables: [&lt;list with_input_variable_names&gt;]\n      output_variable: &lt;one_output_variable_name&gt;\n</code></pre> <p>The classification rule allows for the classification based on the range of one or multiple input vairables. The value range can be indicated in multiple ways. This rule can be used for indicating suitability (0 or 1) or specify categories (1,2,3 etc). The rule will start with the last given criteria range row and work upwards, hence overwriting is possible. Currently there is no check whether possible ranges have been missed or are overlapping.</p> <p>The rule needs to be applied to an existing 2D/3D variables with or without time axis. A new 2D/3D variable with or without time axis is created when the rule is executed.</p> <p>Criteria ranges available are:</p> Criteria range Example Description \"-\" \"-\" Value is not applicable to category, all is allowed \"criteria_value\" \"5\" Value is exectly the criteria value (only applicable for integers) \"&gt;criteria_value\" \"&gt;1\" Value needs to larger than criteria value \"&lt;criteria_value\" \"&lt;0.5\" Value needs to be smaller than criteria value \"&gt;criteria_value\" \"&gt;=1\" Value needs to larger than or equal to criteria value \"&lt;criteria_value\" \"&lt;=0.5\" Value needs to be smaller than or equal to criteria value \"criteria_value1:criteria_value2\" \"0.2:4\" Value needs to be equal or be in between criteria_value1 and criteria_value2 <pre><code>#EXAMPLE  : Determine the suitability for aquatic vegetation based on classification\n  - classification_rule:\n      name: Classification for aquatic plants\n      description: Derive the classification for aquatic plants based on water depth, flow velocity and chloride levels\n      criteria_table:\n        - [\"output\", \"MIN_water_depth_mNAP\", \"MAX_flow_velocity\", \"MAX_chloride\"]\n        - [     1  ,               \"&lt;0.10\" ,                \"-\" ,            \"-\"] # too dry\n        - [     2  ,                \"&gt;4.0\" ,                \"-\" ,            \"-\"] # too deep\n        - [     3  ,                   \"-\" ,                \"-\" ,         \"&gt;400\"] # too salty\n        - [     4  ,                   \"-\" ,             \"&gt;1.5\" ,            \"-\"] # too fast flowing\n        - [     5  ,            \"0.10:4.0\" ,          \"0.0:1.5\" ,       \"0:400\"] # perfect for aquatic plants\n      input_variables: [\"MIN_water_depth_mNAP\", \"MAX_flow_velocity\", \"MAX_chloride\"]\n      output_variable: aquatic_plant_classes\n\n\n  - classification_rule:\n      name: Suitability for aquatic plants\n      description: Derive the suitability for aquatic plants based on the classification\n      criteria_table:\n        - [\"output\", \"aquatic_plant_classes\"]\n        - [     0  ,                   \"1:4\"] # not suitable\n        - [     1  ,                     \"5\"] # suitable\n      input_variables: [\"aquatic_plant_classes\"]\n      output_variable: aquatic_plant_suitability\n\n</code></pre> <p></p> <p></p>"},{"location":"manual/input/#rolling-statistic-rule","title":"Rolling statistic rule","text":"<pre><code>FORMAT\n- rolling_statistics_rule:\n      name: &lt;name_of_rule_in_text&gt;\n      description: &lt;description_of_rule_in_text&gt;\n      operation: &lt;statistic_opperation_applied&gt;\n      time_scale : &lt;time_step_unit_applied&gt;\n      period: &lt;time_step_value_applied&gt;\n      input_variable: &lt;one_input_variable_name&gt;\n      output_variable: &lt;one_output_variable_name&gt;\n</code></pre> <p>The rolling statistic rule allows for a rolling statistic based on the chosen operation and the time period over which the statistic should be repeated. The calculated statistic will be written to each last timestep that falls within the period. Operations available: Add, Average, Median, Min, Max, count_periods, Stdev and Percentile(n). When using percentile, add a number for the nth percentile with brackets like this: percentile(10).</p> <p>Time scales available: hour, day Period can be a float or integer value.</p> <p>The rule needs to be applied to an existing 2D/3D variables with time axis. A new 2D/3D variable with the same time axis is created when the rule is executed.</p> <p>An explanation of how the rolling statistic rule works is shown in the table below:</p> timestep 1 2 3 4 5 6 7 8 period1 - - - i period2 - - - i period3 - - - i <p>In the example shown above the stripe indicates the time period covered (4 timesteps in this case) and with i the location where the result of the statistic over that period is written. Hence, the first three timesteps in this example will not contain any values. This is repeated until the time series has been covered.</p> <pre><code>#EXAMPLE  : Determine a rolling statistic over salinity levels\n  - rolling_statistics_rule:\n      name: test rolling statistic 12.5 hours\n      description: test rolling statistic 12.5 hours\n      operation: MAX\n      time_scale: hour\n      period: 12.5\n      input_variable: IN_salinity_PSU\n      output_variable: salinity_tl_hour_max\n\n  - rolling_statistics_rule:\n      name: test rolling statistic 7 days\n      description: test rolling statistic 7 days\n      operation: MAX\n      time_scale: day\n      period: 7\n      input_variable: IN_salinity_PSU\n      output_variable: salinity_tl_week_max\n</code></pre> <p></p> <p></p>"},{"location":"manual/input/#axis-filter-rule","title":"Axis filter rule","text":"<pre><code>FORMAT\n- axis_filter_rule:\n      name: &lt;name_of_rule_in_text&gt;\n      description: &lt;description_of_rule_in_text&gt;\n      axis_name: &lt;name_of_axis_applied&gt;\n      layer_number: &lt;integer_nr_of_layer_in_axis_applied&gt;\n      input_variable: &lt;one_3D_input_variable_name&gt;\n      output_variable: &lt;one_output_variable_name&gt; \n</code></pre> <p>The axis filter rule is close to the layer_filter_rule, however it allows for filtering on any axis present in the data. This allows for the selection of a specific time step, spatial cell or other data axis value.</p> <p>The rule needs to be applied to an existing 2D/3D variables with or without time axis. A new 2D/3D variable with or without time axis is created when the rule is executed, with the exception of the axis that was filtered upon.</p> <pre><code>#EXAMPLE  : Select only the salinity in the cell for the channel entrance from the faces\n  - axis_filter_rule:\n      name: Filter face of channel entrance (13th face cell)\n      description: Filter face of channel entrance (13th face cell)\n      axis_name: mesh2d_nFaces\n      layer_number: 13\n      input_variable: IN_salinity_PSU\n      output_variable: salinity_PSU_channel_entrance\n</code></pre> <p></p>"},{"location":"manual/input/#depth-average-rule","title":"Depth average rule","text":"<pre><code>FORMAT\n- depth_average_rule:\n      name: &lt;name_of_rule_in_text&gt;\n      description: &lt;description_of_rule_in_text&gt;\n      input_variable: &lt;one_input_variable_name&gt;\n      bed_level_variable: &lt;variable_indicating_bed_level&gt;\n      water_level_variable: &lt;variable_indicating_water_level&gt;\n      interfaces_variable: &lt;variable_indicating_interfaces&gt;\n      output_variable: &lt;one_output_variable_name&gt;\n</code></pre> <p>The depth average rule allows for an averaging over depth using the weighted values according to a mesh with z- or sigma-layers. The current implementation is only tested for input netCDF files generated by D-Hydro. The input file must include a variable containing the location of the horizontal interfaces between the layers over which the input variable will be averaged. Also two variables specifying the bedlevel and water level are needed. The input_variable will be a 2D/3D variable, with or without time axis. The output_variable has the same dimensions, excluding the dimension for the depth, as it will be represented as one averaged value per cell.</p> <p>Note: combined z-sigma layers are currently not supported.</p> <p>An explanation of how the depth rule works is shown in the example below.</p> <p></p> <p>The image shows a simplified model with the following dimensions: - mesh2d_nFaces = 6 (number of faces) - mesh2d_nLayers = 4 (number of layers in the z direction) - mesh2d_nInterfaces = 5 (number of interfaces that define the depth) - time = 2</p> <p>Below are the variables belonging to this example:</p> \\[ mesh2d\\_interface\\_z_{(mesh2d\\_nInterfaces)} = \\begin{bmatrix} \\ 0 \\\\ \\ -2 \\\\ \\ -5 \\\\ \\ -6.5 \\\\ \\ -8.5 \\\\ \\end{bmatrix} \\] \\[ salinity _{(time, nFaces, nLayers)}= \\begin{bmatrix}       \\begin{bmatrix}             1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\\\             2 &amp; 2 &amp; 2 &amp; 2 &amp; 2 &amp; 2 \\\\             3 &amp; 3 &amp; 3 &amp; 3 &amp; 3 &amp; 3 \\\\             4 &amp; 4 &amp; 4 &amp; 4 &amp; 4 &amp; 4       \\end{bmatrix}       \\begin{bmatrix}             1 &amp; 1 &amp; NaN &amp; 1 &amp; 1 &amp; 1 \\\\             2 &amp; 2 &amp; 2 &amp; 2 &amp; 2 &amp; 2 \\\\             3 &amp; 3 &amp; 3 &amp; 3 &amp; 3 &amp; 3 \\\\             4 &amp; 4 &amp; 4 &amp; 4 &amp; 4 &amp; 4       \\end{bmatrix} \\end{bmatrix} \\] \\[ mesh2d\\_s1 _{(mesh2d\\_nFaces, time)} = \\begin{bmatrix}       -1.4 &amp; 0 \\\\       -1.6 &amp; -1.6 \\\\       -3 &amp; -3 \\\\       -1.4 &amp; 3 \\\\       -1.6 &amp; -1.6 \\\\       -1.6 &amp; -1.6 \\end{bmatrix} \\] \\[ mesh2d\\_flowelem\\_bl _{(mesh2d\\_nFaces)}= \\begin{bmatrix}       -7.8 \\\\ -7.3 \\\\ -5.2 \\\\-9.5 \\\\ -7 \\\\ -1.6 \\\\ \\end{bmatrix} \\] <p>This example results in the following output_variable.</p> \\[ input\\_variable _{(nFaces, time)}= \\begin{bmatrix}       2.546875 &amp; 2.269231 \\\\       2.473684 &amp; 2.473684 \\\\       2.090909 &amp; 2.090909 \\\\       2.851852 &amp; 2.2 \\\\       2.388889 &amp; 2.388889 \\\\       NaN &amp; NaN \\\\ \\end{bmatrix} \\] <p>Below is an example of an input_file for the depth average rule:</p> <pre><code>#EXAMPLE  : Determine a depth average for over salinity\n  - depth_average_rule:\n      name: test depth average\n      description: Test depth average\n      input_variable: salinity\n      bed_level_variable: mesh2d_flowelem_bl\n      water_level_variable: mesh2d_s1\n      interfaces_variable: mesh2d_interfaces_sigma\n      output_variable: average_salinity\n</code></pre>"},{"location":"manual/input/#filter-extremes-rule","title":"Filter extremes rule","text":"<pre><code>FORMAT\n- filter_extremes_rule:\n      name: &lt;name_of_rule_in_text&gt;\n      description: &lt;description_of_rule_in_text&gt;\n      input_variable: &lt;one_input_variable_name&gt;\n      output_variable: &lt;one_output_variable_name&gt;\n      extreme_type: troughs or peaks\n      distance: &lt;int_of_time_scale&gt;\n      time_scale: second, hour, day, month or year\n      mask: &lt;boolean&gt;\n</code></pre> <p>The filter extremes rule allows for temporal filtering of extremes in a dataset, i.e. peaks (local maxima) and troughs (local minima). The input variable can be any dimension, as long as it has a time dimension. If the variable mask = False, the output is a variable with the same shape as the input, but only values where the peaks occur and NaN values where no peak occur. If mask = True the output is a same sized variable with 1 (True) at the peak values and NaN elsewhere. Furthermore the user can add a distance (with timescale) as input to define the minimum distance between two peaks/troughs. This mask can be applied to another layer with the combine rule (operation: multiply).</p> <p>Below an example of an input file to use the filter_extremes_rule.</p> <pre><code>#EXAMPLE  : Determine the peak waterlevel values\n  - depth_average_rule:\n      name: test filter extremes\n      description: test filter extremes\n      input_variable: water_level\n      output_variable: water_level_mask\n      extreme_type: peaks\n      distance: 12\n      time_scale: hour\n      mask: True\n</code></pre> <p>The input above is part of a simple test to calculate the salinity at the peaks and troughs of the waterlevel. The extreme filter rule is first used to get the locations of the peaks and throughs of the water level (mask = True) and then with the combine rule the values of the salinity at these points are calculated. The figure below shows these results, the salinity (blue line) and water level are plotted (orange line). The calculated peaks and troughs are shown in purple and green respectively. This example can be reproduced with an iPython notebook (in D-EcoImpact/scripts/test_extreme_filter.ipynb), in this file is also the input_file.yaml included that is used for the calculation.</p> <p></p>"},{"location":"manual/input/#including-data-from-another-yaml-file","title":"Including data from another YAML file","text":"<p>It is possible to include data in the YAML file that originates from another file. At the moment this is only applicable to another YAML file. This can be useful for storing large classification_rule tables in a separate file (for a better overview of the work file), but this functionality is not limited to that specific rule.</p> <p>Here is the original rule:</p> <pre><code>#EXAMPLE  : Original\n# This is a simplified example, only top layer of flow velocity and chloride was used and year statistics\n\n  - classification_rule:\n      name: classification for aquatic plants\n      description: classification for aquatic plants based on water depth, flow velocity and chloride.\n      criteria_table:\n        - [\"output\", \"MIN_water_depth_mNAP\", \"MAX_flow_velocity\", \"MAX_chloride\"]\n        - [     1  ,               \"&lt;0.10\" ,                \"-\" ,            \"-\"] # too dry\n        - [     2  ,                \"&gt;4.0\" ,                \"-\" ,            \"-\"] # too deep\n        - [     3  ,                   \"-\" ,                \"-\" ,         \"&gt;400\"] # too salty\n        - [     4  ,                   \"-\" ,             \"&gt;1.5\" ,            \"-\"] # too fast flowing\n        - [     5  ,            \"0.10:4.0\" ,          \"0.0:1.5\" ,        \"0:400\"] # perfect for aquatic plants\n</code></pre> <p>And this is the rule while making using of an inclusion from another file:</p> <pre><code>#EXAMPLE  : Original\n# This is a simplified example, only top layer of flow velocity and chloride was used and year statistics\n\n  - classification_rule:\n      name: classification for aquatic plants\n      description: classification for aquatic plants based on water depth, flow velocity and chloride.\n      criteria_table: !include tables/aquatic_plant_criteria.yaml\n      input_variables: [\"MIN_water_depth_mNAP\", \"MAX_flow_velocity\", \"MAX_chloride\"]\n      output_variable: aquatic_plant_classes\n</code></pre> <p>And this is the included file from tables/aquatic_plant_criteria.yaml:</p> <pre><code>        - [\"output\", \"MIN_water_depth_mNAP\", \"MAX_flow_velocity\", \"MAX_chloride\"]\n        - [     1  ,               \"&lt;0.10\" ,                \"-\" ,            \"-\"] # too dry\n        - [     2  ,                \"&gt;4.0\" ,                \"-\" ,            \"-\"] # too deep\n        - [     3  ,                   \"-\" ,                \"-\" ,         \"&gt;400\"] # too salty\n        - [     4  ,                   \"-\" ,             \"&gt;1.5\" ,            \"-\"] # too fast flowing\n        - [     5  ,            \"0.10:4.0\" ,          \"0.0:1.5\" ,        \"0:400\"] # perfect for aquatic plants\n</code></pre>"},{"location":"manual/visualization/","title":"Visualization of input and output data","text":"<p>There are multiple ways that the data used and produced can be visualized. Here the use of Panoply to explore the data construct, Quickplot for 2D horizontal and 3D vertical visualization and QGIS for spatial relevant visualization are discussed.</p>"},{"location":"manual/visualization/#panoply","title":"Panoply","text":"<p>Panoply is a NetCDF viewer developed by NASA GISS. Panoply can be downloaded here.</p> <p>Panoply is useful for exploring the content of NetCDF files. It allows the user to see which variables are present in the file, over which dimensions these variables contain values (e.g. x, y, z, time) and what metadata is supplied with each variable. Especially when you have gotten a NetCDF file that you are not familiar with on which data it contains it can be useful to open it first with Panoply.</p> <p></p>"},{"location":"manual/visualization/#quickplot","title":"Quickplot","text":"<p>Quickplot is a Deltares visualization tool used amongst others for Delft3D 4 and Delft3D-FM models. Intern Deltares the latest version of Quickplot can be gathered here:</p> <p>Quickplot is also co-delivered with the installation of one of the Delft3D suites. </p> <p>Quickplot allows the visualization of UGRID NetCDF files, both in the horizontal, over time and in the vertical (for 3D models). </p> <p></p>"},{"location":"manual/visualization/#qgis","title":"QGIS","text":"<p>QuantumGIS (QGIS) is open source free ware GIS software. The latest version of QGIS can be downloaded here</p> <p>QGIS can handle 2D Mesh data directly. See the QGIS 3.28 documentation here. QGIS does however not recognize our newly created time axes (e.g. time_year, time_month after using the D-Eco Impact \"time_aggregation_rule\").</p> <p>When it comes to 3D mesh data a Deltares plugin developed by Jan Mooiman (QGIS_Qmesh) can perform the visualisation. Also visualization through time is made easy with the QGIS_Qmesh plugin. Intern Deltares the latest version of this plugin can be gathered here: needs to be externally compiled here.</p> <p>When Mesh data is loaded directly in QGIS the spatial relevance can be easily displayed using the plugin QuickMapServices &gt; OSM layer.</p> <p></p> <p></p>"},{"location":"manual/rules/axis_filter_rule/","title":"Axis filter rule","text":""},{"location":"manual/rules/axis_filter_rule/#axis-filter-rule","title":"Axis filter rule","text":"<pre><code>FORMAT\n- axis_filter_rule:\n      name: &lt;name_of_rule_in_text&gt;\n      description: &lt;description_of_rule_in_text&gt;\n      axis_name: &lt;name_of_axis_applied&gt;\n      layer_number: &lt;integer_nr_of_layer_in_axis_applied&gt;\n      input_variable: &lt;one_3D_input_variable_name&gt;\n      output_variable: &lt;one_output_variable_name&gt; \n</code></pre> <p>The axis filter rule is close to the layer_filter_rule, however it allows for filtering on any axis present in the data. This allows for the selection of a specific time step, spatial cell or other data axis value.</p> <p>The rule needs to be applied to an existing 2D/3D variables with or without time axis. A new 2D/3D variable with or without time axis is created when the rule is executed, with the exception of the axis that was filtered upon.</p> <pre><code>#EXAMPLE  : Select only the salinity in the cell for the channel entrance from the faces\n  - axis_filter_rule:\n      name: Filter face of channel entrance (13th face cell)\n      description: Filter face of channel entrance (13th face cell)\n      axis_name: mesh2d_nFaces\n      layer_number: 13\n      input_variable: IN_salinity_PSU\n      output_variable: salinity_PSU_channel_entrance\n</code></pre> <p></p>"},{"location":"manual/rules/classification_rule/","title":"Classification rule","text":""},{"location":"manual/rules/classification_rule/#multiple-classification-rule","title":"(Multiple) Classification rule","text":"<pre><code>FORMAT\n- classification_rule:\n      name: &lt;name_of_rule_in_text&gt;\n      description: &lt;description_of_rule_in_text&gt;\n      criteria_table:\n            - [ \"output\"       , &lt;input_variable_name1&gt;, &lt;input_variable_name2&gt;]\n            - [&lt;response_value&gt;,       &lt;criteria_range&gt;,       &lt;criteria_range&gt;]\n            - [&lt;response_value&gt;,       &lt;criteria_range&gt;,       &lt;criteria_range&gt;]\n      input_variables: [&lt;list with_input_variable_names&gt;]\n      output_variable: &lt;one_output_variable_name&gt;\n</code></pre> <p>The classification rule allows for the classification based on the range of one or multiple input vairables. The value range can be indicated in multiple ways. This rule can be used for indicating suitability (0 or 1) or specify categories (1,2,3 etc). The rule will start with the last given criteria range row and work upwards, hence overwriting is possible. Currently there is no check whether possible ranges have been missed or are overlapping.</p> <p>The rule needs to be applied to an existing 2D/3D variables with or without time axis. A new 2D/3D variable with or without time axis is created when the rule is executed.</p> <p>Criteria ranges available are:</p> Criteria range Example Description \"-\" \"-\" Value is not applicable to category, all is allowed \"criteria_value\" \"5\" Value is exectly the criteria value (only applicable for integers) \"&gt;criteria_value\" \"&gt;1\" Value needs to larger than criteria value \"&lt;criteria_value\" \"&lt;0.5\" Value needs to be smaller than criteria value \"&gt;criteria_value\" \"&gt;=1\" Value needs to larger than or equal to criteria value \"&lt;criteria_value\" \"&lt;=0.5\" Value needs to be smaller than or equal to criteria value \"criteria_value1:criteria_value2\" \"0.2:4\" Value needs to be equal or be in between criteria_value1 and criteria_value2 <pre><code>#EXAMPLE  : Determine the suitability for aquatic vegetation based on classification\n  - classification_rule:\n      name: Classification for aquatic plants\n      description: Derive the classification for aquatic plants based on water depth, flow velocity and chloride levels\n      criteria_table:\n        - [\"output\", \"MIN_water_depth_mNAP\", \"MAX_flow_velocity\", \"MAX_chloride\"]\n        - [     1  ,               \"&lt;0.10\" ,                \"-\" ,            \"-\"] # too dry\n        - [     2  ,                \"&gt;4.0\" ,                \"-\" ,            \"-\"] # too deep\n        - [     3  ,                   \"-\" ,                \"-\" ,         \"&gt;400\"] # too salty\n        - [     4  ,                   \"-\" ,             \"&gt;1.5\" ,            \"-\"] # too fast flowing\n        - [     5  ,            \"0.10:4.0\" ,          \"0.0:1.5\" ,       \"0:400\"] # perfect for aquatic plants\n      input_variables: [\"MIN_water_depth_mNAP\", \"MAX_flow_velocity\", \"MAX_chloride\"]\n      output_variable: aquatic_plant_classes\n\n\n  - classification_rule:\n      name: Suitability for aquatic plants\n      description: Derive the suitability for aquatic plants based on the classification\n      criteria_table:\n        - [\"output\", \"aquatic_plant_classes\"]\n        - [     0  ,                   \"1:4\"] # not suitable\n        - [     1  ,                     \"5\"] # suitable\n      input_variables: [\"aquatic_plant_classes\"]\n      output_variable: aquatic_plant_suitability\n\n</code></pre> <p></p> <p></p>"},{"location":"manual/rules/combine_results_rule/","title":"Combine results rule","text":""},{"location":"manual/rules/combine_results_rule/#combine-results-rule","title":"Combine results rule","text":"<pre><code>FORMAT\n- combine_results_rule:\n      name: &lt;name_of_rule_in_text&gt;\n      description: &lt;description_of_rule_in_text&gt;\n      operation: &lt;statistic_opperation_applied&gt;\n      input_variables: [&lt;list with_input_variable_names&gt;]\n      output_variable: &lt;one_output_variable_name&gt;\n</code></pre> <p>The combine results rule combines the output of two or more variables to one output variable. The way this data is combined depends on the operation chosen. This could be used for adding mutual exclusive results (e.g., habitat suitability based on flow velocity and water depth) or asses difference between results (e.g., waterlevel and bathymetry to get the water depth).The rule operates one or multiple  3D variables or 2D variables, independent of the time axes, as long as these all have the same dimensions and returns a single 3D or 2D result, either with time axis, depending on input.</p> <p>Operations available: Add, Subtract, Multiply, Average, Median, Min and Max</p> <p>The rule needs to be applied to an existing 2D/3D variables with or without time axis. A new 2D/3D variable with or without time axis is created when the rule is executed.</p> <pre><code>#EXAMPLE  : Calculate bathymetry over time\n# This is just an example, there is a variable bed level without time (mesh2d_flowelem_bl)\n\n- combine_results_rule:\n      name: Calculate bathymetry\n      description: Calculate bathymetry over time by adding water level and water depth\n      operation: subtract\n      input_variables: [\"water_level\",\"water_depth\"]\n      output_variable: bathymetry_time\n\n</code></pre> <p></p> <p></p>"},{"location":"manual/rules/depth_average_rule/","title":"Depth average rule","text":""},{"location":"manual/rules/depth_average_rule/#depth-average-rule","title":"Depth average rule","text":"<pre><code>FORMAT\n- depth_average_rule:\n      name: &lt;name_of_rule_in_text&gt;\n      description: &lt;description_of_rule_in_text&gt;\n      input_variable: &lt;one_input_variable_name&gt;\n      bed_level_variable: &lt;variable_indicating_bed_level&gt;\n      water_level_variable: &lt;variable_indicating_water_level&gt;\n      interfaces_variable: &lt;variable_indicating_interfaces&gt;\n      output_variable: &lt;one_output_variable_name&gt;\n</code></pre> <p>The depth average rule allows for an averaging over depth using the weighted values according to a mesh with z- or sigma-layers. The current implementation is only tested for input netCDF files generated by D-Hydro. The input file must include a variable containing the location of the horizontal interfaces between the layers over which the input variable will be averaged. Also two variables specifying the bedlevel and water level are needed. The input_variable will be a 2D/3D variable, with or without time axis. The output_variable has the same dimensions, excluding the dimension for the depth, as it will be represented as one averaged value per cell.</p> <p>Note: combined z-sigma layers are currently not supported.</p> <p>An explanation of how the depth rule works is shown in the example below.</p> <p></p> <p>The image shows a simplified model with the following dimensions: - mesh2d_nFaces = 6 (number of faces) - mesh2d_nLayers = 4 (number of layers in the z direction) - mesh2d_nInterfaces = 5 (number of interfaces that define the depth) - time = 2</p> <p>Below are the variables belonging to this example:</p> \\[ mesh2d\\_interface\\_z_{(mesh2d\\_nInterfaces)} = \\begin{bmatrix} \\ 0 \\\\ \\ -2 \\\\ \\ -5 \\\\ \\ -6.5 \\\\ \\ -8.5 \\\\ \\end{bmatrix} \\] \\[ salinity _{(time, nFaces, nLayers)}= \\begin{bmatrix}       \\begin{bmatrix}             1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\\\             2 &amp; 2 &amp; 2 &amp; 2 &amp; 2 &amp; 2 \\\\             3 &amp; 3 &amp; 3 &amp; 3 &amp; 3 &amp; 3 \\\\             4 &amp; 4 &amp; 4 &amp; 4 &amp; 4 &amp; 4       \\end{bmatrix}       \\begin{bmatrix}             1 &amp; 1 &amp; NaN &amp; 1 &amp; 1 &amp; 1 \\\\             2 &amp; 2 &amp; 2 &amp; 2 &amp; 2 &amp; 2 \\\\             3 &amp; 3 &amp; 3 &amp; 3 &amp; 3 &amp; 3 \\\\             4 &amp; 4 &amp; 4 &amp; 4 &amp; 4 &amp; 4       \\end{bmatrix} \\end{bmatrix} \\] \\[ mesh2d\\_s1 _{(mesh2d\\_nFaces, time)} = \\begin{bmatrix}       -1.4 &amp; 0 \\\\       -1.6 &amp; -1.6 \\\\       -3 &amp; -3 \\\\       -1.4 &amp; 3 \\\\       -1.6 &amp; -1.6 \\\\       -1.6 &amp; -1.6 \\end{bmatrix} \\] \\[ mesh2d\\_flowelem\\_bl _{(mesh2d\\_nFaces)}= \\begin{bmatrix}       -7.8 \\\\ -7.3 \\\\ -5.2 \\\\-9.5 \\\\ -7 \\\\ -1.6 \\\\ \\end{bmatrix} \\] <p>This example results in the following output_variable.</p> \\[ input\\_variable _{(nFaces, time)}= \\begin{bmatrix}       2.546875 &amp; 2.269231 \\\\       2.473684 &amp; 2.473684 \\\\       2.090909 &amp; 2.090909 \\\\       2.851852 &amp; 2.2 \\\\       2.388889 &amp; 2.388889 \\\\       NaN &amp; NaN \\\\ \\end{bmatrix} \\] <p>Below is an example of an input_file for the depth average rule:</p> <pre><code>#EXAMPLE  : Determine a depth average for over salinity\n  - depth_average_rule:\n      name: test depth average\n      description: Test depth average\n      input_variable: salinity\n      bed_level_variable: mesh2d_flowelem_bl\n      water_level_variable: mesh2d_s1\n      interfaces_variable: mesh2d_interfaces_sigma\n      output_variable: average_salinity\n</code></pre>"},{"location":"manual/rules/filter_extremes_rule/","title":"Filter extremes rule","text":""},{"location":"manual/rules/filter_extremes_rule/#filter-extremes-rule","title":"Filter extremes rule","text":"<pre><code>FORMAT\n- filter_extremes_rule:\n      name: &lt;name_of_rule_in_text&gt;\n      description: &lt;description_of_rule_in_text&gt;\n      input_variable: &lt;one_input_variable_name&gt;\n      output_variable: &lt;one_output_variable_name&gt;\n      extreme_type: troughs or peaks\n      distance: &lt;int_of_time_scale&gt;\n      time_scale: second, hour, day, month or year\n      mask: &lt;boolean&gt;\n</code></pre> <p>The filter extremes rule allows for temporal filtering of extremes in a dataset, i.e. peaks (local maxima) and troughs (local minima). The input variable can be any dimension, as long as it has a time dimension. If the variable mask = False, the output is a variable with the same shape as the input, but only values where the peaks occur and NaN values where no peak occur. If mask = True the output is a same sized variable with 1 (True) at the peak values and NaN elsewhere. Furthermore the user can add a distance (with timescale) as input to define the minimum distance between two peaks/troughs. This mask can be applied to another layer with the combine rule (operation: multiply).</p> <p>Below an example of an input file to use the filter_extremes_rule.</p> <pre><code>#EXAMPLE  : Determine the peak waterlevel values\n  - depth_average_rule:\n      name: test filter extremes\n      description: test filter extremes\n      input_variable: water_level\n      output_variable: water_level_mask\n      extreme_type: peaks\n      distance: 12\n      time_scale: hour\n      mask: True\n</code></pre> <p>The input above is part of a simple test to calculate the salinity at the peaks and troughs of the waterlevel. The extreme filter rule is first used to get the locations of the peaks and throughs of the water level (mask = True) and then with the combine rule the values of the salinity at these points are calculated. The figure below shows these results, the salinity (blue line) and water level are plotted (orange line). The calculated peaks and troughs are shown in purple and green respectively. This example can be reproduced with an iPython notebook (in D-EcoImpact/scripts/test_extreme_filter.ipynb), in this file is also the input_file.yaml included that is used for the calculation.</p> <p></p>"},{"location":"manual/rules/formula_rule/","title":"Formula rule","text":""},{"location":"manual/rules/formula_rule/#formula-rule","title":"Formula rule","text":"<pre><code>FORMAT\n- formula_rule:\n      name: &lt;name_of_rule_in_text&gt;\n      description: &lt;description_of_rule_in_text&gt;\n      formula: &lt;statistic_opperation_applied&gt;\n      input_variables: [&lt;list with_input_variable_names&gt;]\n      output_variable: &lt;one_output_variable_name&gt;\n</code></pre> <p>With the formula based rule multiple variables can be combined in a flexible way. Operations that are supported are the standard operators.</p> <p>The rule needs to be applied to an existing 2D/3D variables with or without time axis. A new 2D/3D variable with or without time axis is created when the rule is executed.</p> <pre><code>#EXAMPLE  : Calculate bathymetry over time\n# This is just an example, there is a variable bedlevel without time (mesh2d_flowelem_bl)\n\n- formula_rule:\n      name: Calculate bathymetry\n      description: Calculate bathymetry over time by adding water level and water depth\n      formula: water_level + water_depth\n      input_variables: [\"water_level\",\"water_depth\"]\n      output_variable: bathymetry_time\n</code></pre> <p>A lot of operators are supported with the formula based rule. Given two variables \"x\" and \"y\", formulas can be implemented for the following operators:</p> Operator Name Example + Addition x + y - Subtraction x - y * Multiplication x * y / Division x / y % Modulus x % y ** Exponentiation x ** y // Floor division x // y <p>When a formula results in a boolean, it will be converted to a float result. Meaning that True = 1 and False = 0. Comparison, logical, identity, identity and bitwise operators are supported:</p> Operator Name Example == Equal x == y != Not equal x != y &gt; Greater than x &gt; y &lt; Less than x &lt; y &gt;= Greater than or equal to x &gt;= y &lt;= Less than or equal to x &lt;= y // Floor division x // y and Returns True if both statements are true x &lt; 5 and  x &lt; 10 or Returns True if one of the statements is true x &lt; 5 or x &lt; 4 not Reverse the result, returns False if the result is true not(x &lt; 5 a is Returns True if both variables are the same object x is y is not Returns True if both variables are not the same object x is not y in Returns True if a sequence with the specified value is present in the object x in y not in Returns True if a sequence with the specified value is not present in the object x not in Operator Name Description Example &amp; AND Sets each bit to 1 if both bits are 1 x &amp; y | OR Sets each bit to 1 if one of two bits is 1 x | y ^ XOR Sets each bit to 1 if only one of two bits is 1 x ^ y ~ NOT Inverts all the bits ~x &lt;&lt; Zero fill left shift Shift left by pushing zeros in from the right and let the leftmost bits fall off x &lt;&lt; 2 &gt;&gt; Signed right shift Shift right by pushing copies of the leftmost bit in from the left, and let the rightmost bits fall off x &gt;&gt; 2 <p>For more information on these operators click here.</p>"},{"location":"manual/rules/layer_filter_rule/","title":"Layer filter rule","text":""},{"location":"manual/rules/layer_filter_rule/#layer-filter-rule","title":"Layer filter rule","text":"<pre><code>FORMAT\n- layer_filter_rule:\n      name: &lt;name_of_rule_in_text&gt;\n      description: &lt;description_of_rule_in_text&gt;\n      layer_number: &lt;integer_nr_of_layer&gt;\n      input_variable: &lt;one_3D_input_variable_name&gt;\n      output_variable: &lt;one_output_variable_name&gt;\n\n</code></pre> <p>The layer filter rule allows for the extraction of a layer from 3D variables. This could be used for extracting the top layer or bottom layer (e.g., from a multi layered model result). The rule operates on all layers in a 3D variable (in the vertical) as in the time axes and returns a 2D result with the time axes intact. The rule needs to be applied to an existing 3D variable. A new 2D variable is created when the rule is executed.</p> <pre><code>#EXAMPLE  : Extracts the chloride concentration at surface.\n  - layer_filter_rule:\n      name: Extract chloride at surface\n      description: Extracts the chloride concentration at surface\n      layer_number: 22\n      input_variable: chloride\n      output_variable: chloride_top_layer\n\n</code></pre> <p></p>"},{"location":"manual/rules/multiply_rule/","title":"Multiply rule","text":""},{"location":"manual/rules/multiply_rule/#multiply-rule","title":"Multiply rule","text":"<pre><code>- multiply_rule:\n      name: &lt;name_of_rule_in_text&gt;\n      description: &lt;description_of_rule_in_text&gt;\n      multipliers: [&lt;value_to_multiply_with&gt;]\n      input_variable: &lt;one_input_variable_name&gt;\n      output_variable: &lt;one_output_variable_name&gt;\n\n- multiply_rule:\n      name: &lt;name_of_rule_in_text&gt;\n      description: &lt;description_of_rule_in_text&gt;\n      multipliers_table:\n            - [\"start_date\", \"end_date\", \"multipliers\"]\n            - [&lt;DD-MM&gt;, &lt;DD-MM&gt;, [&lt;value_to_multiply_with&gt;]]\n            - [&lt;DD-MM&gt;, &lt;DD-MM&gt;, [&lt;value_to_multiply_with&gt;]]\n      input_variable: &lt;one_input_variable_name&gt;\n      output_variable: &lt;one_output_variable_name&gt;\n</code></pre> <p>The multiply rule allows for multiplication of variables. This could be used for unit transformation (e.g., salinity to chloride) or scenario creation (e.g., water level 80% of existing value). The rule operates on all cells both 3D (in horizontal as vertical) as in the time axes. The same dimensions are returned at the output variable. The rule needs to be applied to an existing variable. A new variable is created when the rule is executed.</p> <p>When using the multiply rule with a start and end date (or multiple start and end dates) all periods that are not covered will be set to NaN. In this way the multiply rule can also be used as a filter in time. NaNs are ignored by any further calculations (for example the time_aggregation_rule).</p> <pre><code>#EXAMPLE: Salinity (psu) to chloride (mg/l) in a freshwater environment.\n- multiply_rule:\n      name: Salinity to chloride\n      description: Converts salinity (psu) to chloride (CL- mg/l) for fresh water environments\n      multipliers: [0.0018066, 1e5]\n      input_variable: salinity\n      output_variable: chloride\n\n- multiply_rule:\n      name: Select only the summer half year for chloride\n      description: Select only the summer half year for chloride as this is important for plant growth\n      multipliers_table:\n            - [\"start_date\", \"end_date\", \"multipliers\"]\n            - [\"15-04\"     , \"15-09\"   ,         [1.0]]\n      input_variable:  chloride\n      output_variable: chloride_grow_period\n\n</code></pre> <p></p>"},{"location":"manual/rules/response_curve_rule/","title":"Response curve rule","text":""},{"location":"manual/rules/response_curve_rule/#response-curve-rule","title":"Response curve rule","text":"<pre><code>FORMAT\n- response_curve_rule:\n      name: &lt;name_of_rule_in_text&gt;\n      description: &lt;description_of_rule_in_text&gt;\n      response_table:\n            - [ \"input\", \"output\"]\n            - [&lt;limit_value&gt;, &lt;response_value&gt;]\n            - [&lt;limit_value&gt;, &lt;response_value&gt;]\n      input_variable: &lt;one_input_variable_name&gt;\n      output_variable: &lt;one_output_variable_name&gt;\n</code></pre> <p>The response curve rule performs a linear interpolation over the provided values of the variables of 3D and 2D variables time dependent arrays. This could be used for a fuzzy logic translation of variables into ecological responses to these variables (e.g., suitability for aquatic plants based on light availability). The rule operates both on 3D variables and 2D variables, independent of the time axes, and returns decimal or fractional values in a 3D or 2D result, either with time axis, depending on input.</p> <p>The rule needs to be applied to an existing 2D/3D variable with or without time axis. A new 2D/3D variable with or without time axis is created when the rule is executed.</p> <pre><code>#EXAMPLE  : Response of the habitat suitability of Long-leaf pond weed\n# (Potamogeton nodosus)  to water depth.\n# Suitable between 0.0 \u2013 2.0 m and highly suitable between 0.5 \u2013 1.0 m\n- response_curve_rule:\n      name: HSI Pond weed water depth\n      description: Reponse of Pond weed (Potamogeton nodosus) to water depth\n      response_table:\n           - [\"input\",   \"output\"]\n           - [-999.0 ,   0.0 ]\n           - [   0.0 ,   0.0 ]\n           - [   0.5 ,   1.0 ]\n           - [   1.0 ,   1.0 ]\n           - [   2.0 ,   0.0 ]\n           - [ 999.0 ,   0.0 ]\n      input_variable: water_depth\n      output_variable: HSI_Pnodosus_water_depth\n\n</code></pre> <p></p> <p></p>"},{"location":"manual/rules/rolling_statistics_rule/","title":"Rolling statistics rule","text":""},{"location":"manual/rules/rolling_statistics_rule/#rolling-statistic-rule","title":"Rolling statistic rule","text":"<pre><code>FORMAT\n- rolling_statistics_rule:\n      name: &lt;name_of_rule_in_text&gt;\n      description: &lt;description_of_rule_in_text&gt;\n      operation: &lt;statistic_opperation_applied&gt;\n      time_scale : &lt;time_step_unit_applied&gt;\n      period: &lt;time_step_value_applied&gt;\n      input_variable: &lt;one_input_variable_name&gt;\n      output_variable: &lt;one_output_variable_name&gt;\n</code></pre> <p>The rolling statistic rule allows for a rolling statistic based on the chosen operation and the time period over which the statistic should be repeated. The calculated statistic will be written to each last timestep that falls within the period. Operations available: Add, Average, Median, Min, Max, count_periods, Stdev and Percentile(n). When using percentile, add a number for the nth percentile with brackets like this: percentile(10).</p> <p>Time scales available: hour, day Period can be a float or integer value.</p> <p>The rule needs to be applied to an existing 2D/3D variables with time axis. A new 2D/3D variable with the same time axis is created when the rule is executed.</p> <p>An explanation of how the rolling statistic rule works is shown in the table below:</p> timestep 1 2 3 4 5 6 7 8 period1 - - - i period2 - - - i period3 - - - i <p>In the example shown above the stripe indicates the time period covered (4 timesteps in this case) and with i the location where the result of the statistic over that period is written. Hence, the first three timesteps in this example will not contain any values. This is repeated until the time series has been covered.</p> <pre><code>#EXAMPLE  : Determine a rolling statistic over salinity levels\n  - rolling_statistics_rule:\n      name: test rolling statistic 12.5 hours\n      description: test rolling statistic 12.5 hours\n      operation: MAX\n      time_scale: hour\n      period: 12.5\n      input_variable: IN_salinity_PSU\n      output_variable: salinity_tl_hour_max\n\n  - rolling_statistics_rule:\n      name: test rolling statistic 7 days\n      description: test rolling statistic 7 days\n      operation: MAX\n      time_scale: day\n      period: 7\n      input_variable: IN_salinity_PSU\n      output_variable: salinity_tl_week_max\n</code></pre> <p></p> <p></p>"},{"location":"manual/rules/step_function_rule/","title":"Step function rule","text":""},{"location":"manual/rules/step_function_rule/#step-function-rule","title":"Step function rule","text":"<pre><code>FORMAT\n- step_function_rule::\n      name: &lt;name_of_rule_in_text&gt;\n      description: &lt;description_of_rule_in_text&gt;\n      limit_response_table:\n            - [ \"limit\", \"response\"]\n            - [&lt;limit_value&gt;, &lt;response_value&gt;]\n            - [&lt;limit_value&gt;, &lt;response_value&gt;]\n      input_variable: &lt;one_input_variable_name&gt;\n      output_variable: &lt;one_output_variable_name&gt;\n</code></pre> <p>The step function rule performs stepwise classification on the provided values of 3D and 2D variables time dependent arrays. This could be used for translating variables into classes (e.g., salinity classes based on salinity) or indicate suitable/unsuitable ranges (e.g., checking whether the water level falls between the maximum and minimum water level policy criteria). The rule operates both on 3D variables and 2D variables, independent of the time axes, and returns a binominal or classes in a 3D or 2D result, either with time axis, depending on input. </p> <p>The rule needs to be applied to an existing 2D/3D variable with or without time axis. A new 2D/3D variable with or without time axis is created when the rule is executed.</p> <pre><code>#EXAMPLE  : Salinity classes.\n    - step_function_rule:\n      name: Classify salinity\n      description: Make distinction between 0.0 \u2013 0.5 , 0.5 \u2013 1.2, 1.2 \u2013 1.3 and &gt;1.3 psu\n      limit_response_table:\n            - [ limit, response]\n            - [-999.0 , 0.0 ]\n            - [   0.0 , 1.0 ]\n            - [   0.5 , 2.0 ]\n            - [   1.2 , 3.0 ]\n            - [   1.3 , 4.0 ]\n            - [ 999.0 , 4.0 ]\n      input_variable: salinity\n      output_variable: salinity_class\n\n</code></pre> <p></p> <p></p> <pre><code>#EXAMPLE  : Check if the water level falls within the range of -0.10 and +0.15 m NAP.\n  - step_function_rule:\n      name: Check water level policy\n      description: Check if water level is within -0.10 (minimum) and +0.15 (maximum) m NAP\n      limit_response_table:\n            - [ limit, response]\n            - [-999.0  , 0.0 ]\n            - [  -0.10 , 1.0 ]\n            - [   0.15 , 0.0 ]\n            - [ 999.0  , 0.0 ]\n      input_variable: water_level\n      output_variable : water_level_policy\n</code></pre> <p></p> <p></p>"},{"location":"manual/rules/time_aggregation_rule/","title":"Time aggregation rule","text":""},{"location":"manual/rules/time_aggregation_rule/#time-aggregation-rule","title":"Time aggregation rule","text":"<pre><code>FORMAT\n- time_aggregation_rule:\n      name: &lt;name_of_rule_in_text&gt;\n      description: &lt;description_of_rule_in_text&gt;\n      operation: &lt;statistic_opperation_applied&gt;\n      time_scale : &lt;time_aggregation_applied&gt;\n      input_variable: &lt;one_input_variable_name&gt;\n      output_variable: &lt;one_output_variable_name&gt;\n</code></pre> <p>The time aggregation rule allows for calculating a statistical summary over the time axes of 3D and 2D variables. This could be used for calculating the maximum value over a year (e.g., for water level) or the minimum value over a month (e.g., oxygen concentration). The rule operates both on 3D variables and 2D variables as long as they have a time axis and returns a 3D or 2D result depending on input with the statistic calculated for a new time axis (e.g., year or month). Operations available: Add, Average, Median, Min, Max, period statistics, Stdev and Percentile(n). When using percentile, add a number for the nth percentile with brackets like this: percentile(10). Stdev calculates the standard- deviation over the time period. Under period statistics are explained further in the text.</p> <p>Time aggregation available: Year, Month</p> <p>The rule needs to be applied to an existing 2D/3D variable with time axis. A new 2D/3D variable with new time axis is created when the rule is executed. With a year timestep the result is written to the last day of the year, with a month timestep the result is written to the last day of the month per year.</p> <pre><code>#EXAMPLE  : Calculate the maximum water level in a year.\n  - time_aggregation_rule:\n      name: Maximum water level year\n      description: Get maximum water level in a year\n      operation: MAX\n      time_scale: year\n      input_variable: water_level\n      output_variable: MAX_water_level_year\n</code></pre> <p></p> <p>Period statistics: Time aggregation rule with COUNT_PERIODS, AVG_DURATION_PERIODS, MIN_DURATION_PERIODS and MAX_DURATION_PERIODS</p> <p>When the operation type period statistics is used, the user needs to make sure that the input data is always consisting of only 1 and 0. If there is no such layer, the user can make a combination of for example the classification rule together with the time aggregation rule. For example, water depth can be used to check whether the cells are dry or not (this can be done with a classification rule) and with the COUNT_PERIODS operation type in the time aggregation rule the number of consecutive periods within a year or month can be calculated (nr). AVG_DURATION_PERIODS, MIN_DURATION_PERIODS and MAX_DURATION_PERIODS take the respective statistic of the duration for those consecutive periods (duration).</p> <pre><code>#EXAMPLE:\n\nCalculate the number of consecutive periods of dry time monthly\n    - classification_rule:\n        name: Classify dry time\n        description: Classify to 0 and 1 the dry time\n        criteria_table:\n            - [\"output\", \"water_depth\"]\n            - [0, \"&gt;0.10\"]\n            - [1, \"&lt;0.10\"]\n        input_variables: [\"water_depth\"]\n        output_variable: dry_time_classified\n\n    - time_aggregation_rule:\n        name: Count periods\n        description: Count periods\n        operation: COUNT_PERIODS\n        time_scale: month\n        input_variable: dry_time_classified\n        output_variable: COUNT_PERIODS_water_level_month\n</code></pre>"}]}